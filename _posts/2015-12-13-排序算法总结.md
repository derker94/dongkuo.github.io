---
layout: post
title:  "排序算法总结——算法导论(补充3)"
date:   2015-12-13 14:04:11 +0800
categories: 算法与数据结构
tags: 算法导论  排序总结
---

> 转载请注明出处，谢谢。

## 1. 写在最前面

到目前为止，我们已经学习了大约6种排序算法，接下来将会再介绍两种。这篇博客主要是对这大约8种排序算法做一个总结。



## 2. 冒泡排序

#### 算法描述

> 比较相邻两个元素大小，如果反序，则交换。

下面是 *Java* 实现代码：

```java
public static void bubbleSort(int[] a) {
    for (int i = 1; i < a.length; i++) {
            for (int j = 0; j < a.length - i; j++) {
                if (a[j] > a[j + 1]) {
                    int temp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = temp;
                }
            }
        }
    }
}
```

下面再对 *冒泡排序* 作一下说明：

*冒泡排序* 有**内外两层循环**，外层循环是用来**控制内层循环每趟遍历的范围**，每趟遍历的范围依次是：[0 ~ end]、[0 ~ end -1]、… [0 ~ 1]；内层循环是用来比较每趟范围内，相邻两个元素的大小，如果反序，则交换。二者结合起来，就能保证在每趟结束（内层循环结束）后，每趟范围内最大（或最小）的元素被置换到该趟范围的末尾。(这也是该算法被称为冒泡的原因：该过程就像沸腾的水中气泡，越上升越大)

#### 算法改进

考虑对{1, 2, 5, 3, 4}序列采用上述算法排序。

我们会发现，在第一趟排序结束后，序列即已经完全有序，但是上述算法仍然会继续第二趟、第三趟...

我们可以到if判断里去做**"标记"**，在外层循环里判断是否做过 *"标记"* ，若做过，说明还需进行排序；否则，说明序列已经完全有序。

改进代码如下：

```java
public static void bubbleSort(int[] a) {
    boolean flag = true;
    for (int i = 1; i < a.length && flag; i++) {
        flag = false;
        for (int j = 0; j < a.length - i; j++) {
            if (a[j] > a[j + 1]) {
                flag = true;
                int temp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = temp;
            }
        }
    }
}
```

#### 算法分析

我们针对改进后的冒泡排序算法进行分析：

1. **最坏情况**：某些随机排列或序列完全反序会造成最坏情况的产生。此时内外循环会完全进行，时间复杂度是O(n<sup>2</sup>);

2. **最好情况**：序列完全正序，此时外层循环只会进行一趟，时间复杂度是O(n);

总之，冒泡排序的时间复杂度介于O(n) ~ O(n<sup>2</sup>)之间;


## 3. 直接选择排序

#### 算法描述

> 第一趟从n个元素中选择出最大或最小的元素放在最前或最后的位置，下一趟再从n-1个元素中选择出最大或最下的元素放在次最前或最后的位置，以此类推，经过n-1趟完成排序。

下面是 *Java* 实现代码：

```java
public static void selectSort(int[] a) {
    for (int i = 0; i < a.length; i++) {
        int indexOfMin = i;
        for (int j = i + 1; j < a.length; j++) {
            if (a[indexOfMin] > a[j]) {
                indexOfMin = j;
            }
        }
        if (indexOfMin != i) {
            int temp = a[indexOfMin];
            a[indexOfMin] = a[i];
            a[i] = temp;
        }
    }
}
```

#### 算法分析

算法比较简单，时间复杂度是O(n<sup>2</sup>)。



## 4. 总结

我们按照排序策略可以将它们大致地分为以下几类：

| 类型| 名称               			   |
|-----|------------------------------|
| 插入| 直接插入排序、希尔排序			|
| 交换| 冒泡排序、快速排序（包括随机化版本）|
| 选择| 直接选择排序、堆排序	         |
| 归并| 归并排序           			 |
| 线性| 计数排序          			|


> 插入排序（Insert Sort）：每趟将一个元素，按其关键字值的大小插入到它前面已经排序的子序列中，依次重复，直到插入全部元素。

...

>  交换排序（Swap Sort）：根据序列中两个元素的关键字值的比较结果来对换这两个元素在序列中的位置，直到各元素在其应该在的位置。

它的特点是：**关键字值较大的元素会向序列的尾部移动，关键值较小的元素会向序列的头部移动（假设从小到大排列）**。

...

> 选择排序（）

...

> 以上内容大部分摘自《算法导论》第3版的中文译本，其中少部分加入了一些个人理解，仅供参考；有些句子和词由于是翻译过来的，所以可能比较突兀，会意就好。
